#include "proyecto.h"
// poner aquí todos los archivos de includes adicionales necesarios

extern double amplitudDistorsion;

void AGris(IplImage * img, IplImage * imgSal)
{
	DWORD y, x;

	for (y = 0; y < img->height; y++)
	{
		// Procesa pixels dentro de cada scanline
		for (x = 0; x < img->width; x++)
		{

			unsigned char * ppix, *ppox;

			// Calcula la dirección del pixel actual
			//imageData inicio imagen
			//y*widthStep inicio la fila y, desde la imagen
			//x*nChannels inicio del pixel desde la fila
			ppix = (unsigned char *)img->imageData + y * img->widthStep + x * img->nChannels;
			ppox = (unsigned char *)imgSal->imageData + y * imgSal->widthStep + x * imgSal->nChannels;

			// Aquí se transforma el color de cada pixel para conseguir los tonos grises
			// Aplica la formula que aparece en el ejercicio:
			/*... Una forma de hacerlo es sustituyendo los valores R, G y B de cada píxel
			por la media ponderada de la luminosidad de los colores del píxel,
			que se calcula como ...
			*/
			double a = 0.3 * (amplitudDistorsion/2);	//Recicla la variable global amplitudDistorsion para cambiar los colores de los pixeles.
			double b = 0.55 * (amplitudDistorsion/2);	//El numero que le pasemos en el miniMenu, mientras mas grende sea, mas iluminacion tendrá la imagen
			double c = 0.15 * (amplitudDistorsion/2);
			//ppox[0] = (0.3*ppix[2] + 0.55*ppix[1] + 0.15*ppix[0]); //Rojo  
			ppox[0] = (a *ppix[2] + b *ppix[1] + c *ppix[0]); //Rojo  
			ppox[2] = ppox[1] = ppox[0];//verde/AZUL
		}
	}
}





