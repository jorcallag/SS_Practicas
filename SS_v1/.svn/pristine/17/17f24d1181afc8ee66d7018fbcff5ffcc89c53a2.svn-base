//MAL MONTAJE ARREGLADO
#include "proyecto.h"
// poner aquí todos los archivos de includes adicionales necesarios

/*int main(int argc, char *argv[])
{
	int tecla;	// permite leer las teclas que pulsa el usuario en las ventanas openCV
	char * nombreVentana;

	// comprueba que el usuario ha puesto el ancho y alto de la imagen en línea de comandos
	CheckError(argc != 3, "Debe haber al menos 2 argumentos (alto y ancho de la imagen)", 1);

	setlocale(LC_ALL, "Spanish"); // Previo

	// Para la imagen original usamos un patrón conocido
	IplImage * imgOriginal = GeneraBMP24cv(atoi(argv[1]), atoi(argv[2]), Patron_10);
	do
	{
		// Muestra la imagen original en una ventana OpenCv hasta que el usuario pulsa una tecla
		nombreVentana = ImagenAVentana(imgOriginal, "Original", "Pulsa una tecla\npara continuar...", false, &tecla);
	} while (tecla == -1);

	//printf("Cerrando primera ventana..."); // <-- descomentar para ejercicio 6.2 
	cvDestroyWindow(nombreVentana);	// cierra la primera ventana
	// crea imagen de resultado
	IplImage* imgResultado = cvCreateImage(CvSize(imgOriginal->width, imgOriginal->height),
		imgOriginal->depth, imgOriginal->nChannels);

	double retrasoAcumulado = 0.0; // permite calcular la velocidad de proceso de las imágenes
	int nroImagenes = 0;
	do
	{
		char mensaje[200];
		MideRetraso(0);	//<-- Solo medimos el tiempo de proceso de la imagen. Desde aquí
		//ProcesaImagen(imgOriginal, imgResultado);
		//AGris(imgOriginal, imgResultado); //<-- Ejercicio 6.8
		TrasMalla(imgOriginal, imgResultado, 0.0, 0.0); //<-- Ejercicio 7.1
		//Sleep(100);
		retrasoAcumulado += MideRetraso(0);	// --> hasta aquí
		nroImagenes++;
		// Construimos el mensaje
		snprintf(mensaje, sizeof(mensaje),
			"procesando %d imagenes en %.2f segs\n(%.2f imgs/s)\nPulsa ENTER para terminar",
			nroImagenes, retrasoAcumulado, nroImagenes / retrasoAcumulado);
		// Muestra el resultado
		ImagenAVentana(imgResultado, "RESULTADO:", mensaje, true, &tecla);
	} while (tecla != 13);	// salimos cuando el usuario pulsa la tecla Retorno

	return 0;
}*/

// Ejercicio 7.2
int main(int argc, char *argv[])
{
	int tecla;
	char * nombreVentana;

	setlocale(LC_ALL, "Spanish"); // Previo
	CheckError(argc != 2, "Debe haber al menos 1 argumentos (nombre archivo de la imagen)", 1);
	
	IplImage* imgOriginal;
	CvCapture* g_capture = cvCreateFileCapture(argv[1]); //Abre el archivo de video
	CheckError (NULL == g_capture, "\n\nERROR: No se pudo abrir el archivo de video\n\n", 1);
	imgOriginal = cvQueryFrame(g_capture); // Lee frame del archivo
	if (NULL == imgOriginal) return 0;

	IplImage* imgResultado = cvCreateImage(CvSize(imgOriginal->width, imgOriginal->height),
		imgOriginal->depth, imgOriginal->nChannels);

	double retrasoAcumulado = 0.0;
	int nroImagenes = 0;
	do
	{
		char mensaje[200];
		MideRetraso(0);	//<-- Solo medimos el tiempo de proceso de la imagen. Desde aquí
		//ProcesaImagen(imgOriginal, imgResultado);
		//AGris(imgOriginal, imgResultado); //<-- Ejercicio 6.8
		TrasMalla(imgOriginal, imgResultado, 0.0, 0.0); //<-- Ejercicio 7.1
		//Sleep(100);
		retrasoAcumulado += MideRetraso(0);	// --> hasta aquí
		nroImagenes++;
		// Construimos el mensaje
		snprintf(mensaje, sizeof(mensaje),
			"procesando %d imagenes en %.2f segs\n(%.2f imgs/s)\nPulsa ENTER para terminar",
			nroImagenes, retrasoAcumulado, nroImagenes / retrasoAcumulado);
		// Muestra el resultado
		ImagenAVentana(imgResultado, "RESULTADO:", mensaje, true, &tecla);
		imgOriginal = cvQueryFrame(g_capture); // Lee frame del archivo
	} while (tecla != '\r' && NULL!=imgOriginal);	

	return 0;
}

