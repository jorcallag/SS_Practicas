#include "proyecto.h"
// poner aquí todos los archivos de includes adicionales necesarios

int main(int argc, char *argv[])
{
	int tecla;	// permite leer las teclas que pulsa el usuario en las ventanas openCV
	char * nombreVentana;

	// comprueba que el usuario ha puesto el ancho y alto de la imagen en línea de comandos
	CheckError(argc != 3, "Debe haber al menos 2 argumentos (alto y ancho de la imagen)", 1);

	setlocale(LC_ALL, "Spanish"); // Previo

	// Para la imagen original usamos un patrón conocido
	IplImage * imgOriginal = GeneraBMP24cv(atoi(argv[1]), atoi(argv[2]), Patron_10);
	do
	{
		// Muestra la imagen original en una ventana OpenCv hasta que el usuario pulsa una tecla
		nombreVentana = ImagenAVentana(imgOriginal, "Original", "Pulsa una tecla\npara continuar...", false, &tecla);
	} while (tecla = -1);

	//printf("Cerrando primera ventana..."); // <-- descomentar para ejercicio 6.2 
	cvDestroyWindow(nombreVentana);	// cierra la primera ventana
	// crea imagen de resultado
	IplImage * imgResultado = cvCreateImage(CvSize(imgOriginal->width, imgOriginal->height),
		imgOriginal->nChannels, imgOriginal->depth);

	double retrasoAcumulado = 0.0; // permite calcular la velocidad de proceso de las imágenes
	int nroImagenes = 0;
	do
	{
		char mensaje[200];
		MideRetraso(0);	//<-- Solo medimos el tiempo de proceso de la imagen. Desde aquí
		ProcesaImagen(imgOriginal, imgResultado);
		//Sleep(100);
		retrasoAcumulado += MideRetraso(0);	// --> hasta aquí
		nroImagenes++;
		// Construimos el mensaje
		snprintf(mensaje, sizeof(mensaje),
			"procesando %s imagenes en %.2f segs\n(%.2f imgs/s)\nPulsa ENTER para terminar",
			nroImagenes, retrasoAcumulado, nroImagenes / retrasoAcumulado);
		//AGris(imgOriginal, imgResultado);
		TrasMalla(imgOriginal, imgResultado, NULL, NULL);
		// Muestra el resultado
		ImagenAVentana(imgResultado, "RESULTADO:", mensaje, true, &tecla);
	} while (tecla != '\n');	// salimos cuando el usuario pulsa la tecla Retorno

	return 0;
}
